"main.py"

# imports
import enum
import time
import math
import monitor
import utils
import db_utils
import numpy as np
# import crypto_check as cr
import os
import threading as th
from encrytor import EN
import warnings
DOWNSAMPLING = 0.3

def isWhitelisted(item, whitelist):
    for i in whitelist:
        if item.strip() == i.strip():
            return True
    return False

def detect_patt(pattern: dict, white_list: dict) -> bool:
    """ pattern detection 
        using duty cylce , wave_length,
        args :
            * pattern (dict) : save the pattern
        returns :
            * bool pattern detected or not
    """
    con = False
    # print(pattern["Malware"])
    # if "Malware" in white_list:
    # print("LOL")
    # print(type(white_list))
    # print("pattern.items")
    # print(pattern.items())
    print(pattern.keys())
    conditions = dict()
    for key, val in pattern.items():
        # print("key", key)

        if key in white_list:

            print("prog", key, "is white listed")
            continue
        # print(key)
        m_arr = np.array([itr for itr in val]).flatten()
        t_arr = np.array([itr for itr in val]).flatten()
        # be aware of processes that uses the same memory always will get zero
        # print("key")
        # print(key)
        # print("m_arr.shape[0]")
        # print(m_arr.shape[0])
        if m_arr.shape[0] > 2:
            threshold = (m_arr.max()+m_arr.min())/2.0
            mask_upper = m_arr > threshold
            mask_lower = m_arr <= threshold
            # numeric shift mask
            mask = np.where(m_arr > threshold)[0]
            # print("mask",mask)
            shift_mask = mask[:mask.shape[0]-1]
            shift_mask = np.hstack((shift_mask[0], shift_mask))
            mask -= shift_mask
            #a = mask - shift_mask
            # print('mask',shift_mask)
            # print(a[a>1.0])
            set_val = set(mask[mask > 1.0])
            # print("set_val")
            # print(set_val)
            # print(len(set_val))
            con = bool(len(set_val) <= 3)
            # ######### #
            # condtion = np.abs(np.sum((m_arr > m_arr.min())) - np.sum(~(m_arr > m_arr.min())))\
            #    < int(math.ceil(0.2*m_arr.shape[0]))
        if con:
            # print("pattern",key)
            conditions[key] = True
    return conditions


def main_monitor(terminate, shell_memory_function, encr_class,
                 init_memory: dict,
                 init_times: dict,
                 black_list: dict,
                 white_list: set,
                 pattern: dict,
                 del_threshold: int = 3):
    """
    monitor the memory
    args:
        * terminate :function to kill the process with pid
        * shell_memory_function: it retrieves current memory data
        * init_memory (dict)
        * init_times (dict)
        * black_list (dict)
        * white_list (set)
        * pattern (dict)

    """

    def get_memory(list_dict: list):
        """"""
        memory, exe_name, name_pid = dict(), dict(), dict()
        for process in list_dict:
            memory[process['pid']] = process['data']
            exe_name[process['pid']] = process['name']

            if name_pid.get(process['name']) is None:
                name_pid[process['name']] = [process['pid']]
            else:
                name_pid[process['name']] = name_pid.get(
                    process['name']) + [process['pid']]
        return memory, exe_name, name_pid

    def get_proccess_name(memory: dict) -> list:
        return list(set(memory.keys()))

    while True:

        init_monitor_time = time.time()
        while int(time.time()-init_monitor_time) < 15:
            data = shell_memory_function()
            memory, exe_name, name_pid = get_memory(data)
            #######################
            #proccesses = get_proccess_name(memory)

            # perfecto
            #{ pid : exe_name.get(pid) for pid in proccesses}

            new_processes = set(exe_name.values()).difference(white_list)
            # new_processes_pid = list(np.array([ np.array(name_pid.get(name).flatten() for name in new_proccesses]).flatten())

            new_processes_pid = []
            [new_processes_pid.extend(name_pid.get(name))
             for name in new_processes]

            # for  name in new_proccesses:
            # new_processes_pid.append(*name_pid.get(name))

            # for prog_pid in proccesses:
            for prog_pid in new_processes_pid:
                if (init_memory.get(prog_pid) is None) or\
                        init_memory.get(prog_pid) > memory[prog_pid]:

                    init_memory[prog_pid] = memory[prog_pid]
                # sampling condtion
                suspect_name = exe_name.get(prog_pid)
                cond = np.random.choice([False, True], size=(
                    1,), p=[abs(1-DOWNSAMPLING), DOWNSAMPLING])[0]

                if cond:  # append pattern
                    # print("Memory...")
                    cur_mem = int(abs(memory[prog_pid]-init_memory[prog_pid]))
                    if pattern.get(suspect_name) is not None:
                        pattern[suspect_name] = pattern.get(suspect_name) + \
                            list((time.time(),
                                  cur_mem))
                    else:
                        pattern[suspect_name] = list((time.time(), cur_mem))


        # time series pattern detection
        # if whitelist
        
        counter = detect_patt(pattern, white_list=white_list)
        # delete pattern to dump a new one
        del pattern
        pattern = dict()
        print("Detected")

        # white_set = set(counter.keys())
        # db_utils.pickle_("white_set.pickle",white_set)
        # black list counter
        print("counter.keys()")
        print(counter.keys())
        for prog_pid, _ in counter.items():
        # if counter:
            black_list[prog_pid] = black_list.get(prog_pid, 0) + 1
            # if black_list.get(prog_pid) is not None:
            # if black_list.get(prog_pid) is not None:
            if black_list[prog_pid] >= del_threshold:
                " elgeded "
                # get the name from data[memory big dictionary]
                #suspect_name = exe_name.get(prog_pid)
                print(
                    '----------------------------   DETECTED   ----------------------------')
                print('suspected a malicious behaviour from pogram', prog_pid)
                # get process path from monitor
                suspect_path = monitor.get_process_path(prog_pid)
                
                # check crypto from utils
                # thread
                # cr.check_exe_path(os.getcwd(),suspect_path)

                inp = utils.timout_input(time=10)

                if inp.lower() in ['y', 'yes', 'ok']:
                    print('Booooom Headshot Process', prog_pid)

                    # Killing all processes that have the same name
                    pids = set(name_pid[prog_pid])
                    for a_pid in pids:
                        terminate(int(a_pid))


                    print("terminated", suspect_name, suspect_path)
                    path = "addf"
                    try:
                        # get path from pid
                        path = monitor.get_process_path(prog_pid)
                        # block or encrypt
                        encr_class.encrypt(path)
                    except:
                        print('pid replaced y norm', prog_pid)

                    # encrept the process
                    # kill it
                    # thread to  user if he wanted back
                    # os.system("taskkill /f /im [suspect_name].exe")
                    # os.remove("/tmp/<file_name>.txt")
                elif inp.lower() in ["n", "no"]:
                    white_list.add(prog_pid)
                    print('added to white_list')
                    continue
        del counter


def main():
    """
    threading for crypto , monitor save white&black lists history data

    crypto gpu > 10%"""

    # to ignore annoying python warnings
    warnings.filterwarnings('ignore')



    # retrieve data base


    #key = str(input("enter encr key"))
    key = "skfjgmkgzk"
    ecr = EN(key)

    # globals
    init_memory = dict()
    init_times = dict()
    black_list = dict()
    pattern = dict()
    white_list = set()
    white_list = utils.whitelist_scraper()
    white_set = db_utils.unpickle("white_set.pickle")
    white_list.union(white_set.difference(set(['Malware','migration/10'])))


    pack = dict(
        init_memory=init_memory,
        init_times=init_times,
        black_list=black_list,
        white_list=white_list,
        pattern=pattern
    )

    # main_monitor(monitor.terminate_process,
    #              monitor.getListOfProcessSortedByMemory, ecr, **pack, del_threshold=10)

    main_monitor(terminate=monitor.terminate_process,
                 shell_memory_function=monitor.getListOfProcessSortedByMemory,
                 encr_class=ecr,
                 del_threshold=2,
                 **pack)
    # every 10 min save the dictionaries


if __name__ == "__main__":
    main()
