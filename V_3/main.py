"main.py"

# imports
import warnings
import time

import threading
import numpy as np
from playsound import playsound

import periodic_update
import monitor
import utils
import db_utils
# import crypto_check as cr
from encryptor import EN, hash_malware, get_hash
from pattern_detector import detect_pattern


DOWNSAMPLING = 0.3

# event = threading.Event()

# def fn():
#     # print(45)
#     event.wait()
#     print("done")

# t1 = threading.Thread(target=fn)
# t1.start()


def is_white_listed(item, whitelist):
    for i in whitelist:
        if item.strip() == i.strip():
            return True
    return False


def main_monitor(terminate, shell_memory_function, encr_class,
                 init_memory: dict,
                 terminated: set,
                 black_list: dict,
                 white_list: set,
                 pattern: dict,
                 del_threshold: int = 3):
    """
    monitor the memory
    args:
        * terminate :function to kill the process with pid
        * shell_memory_function: it retrieves current memory data
        * init_memory (dict)
        * init_times (dict)
        * black_list (dict)
        * white_list (set)
        * pattern (dict)

    """
    while True:

        init_monitor_time = time.time()
        while int(time.time()-init_monitor_time) < 15:

            data = shell_memory_function()
            memory_dict, exe_name_dict, name_pid_dict = utils.get_memory(data)

            new_processes = set(exe_name_dict.values()).difference(white_list)

            new_processes_pid = []
            [
                new_processes_pid.extend(name_pid_dict.get(name))
                for name in new_processes
            ]

            for prog_pid in new_processes_pid:
                suspect_name = exe_name_dict.get(prog_pid)
                if suspect_name in terminated:

                    path = monitor.get_process_path(suspect_name)
                    hashes = get_hash(path)
                    # event listener
                    "git"
                    pids = set(name_pid_dict[suspect_name])
                    for pid in pids:
                        # hash
                        terminate(int(pid))

                if (init_memory.get(prog_pid) is None) or\
                        init_memory.get(prog_pid) > memory_dict[prog_pid]:

                    init_memory[prog_pid] = memory_dict[prog_pid]

                # sampling condtion
                suspect_name = exe_name_dict.get(prog_pid)
                sampling_condition = np.random.choice([False, True], size=(
                    1,), p=[abs(1-DOWNSAMPLING), DOWNSAMPLING])[0]

                if sampling_condition:  # append pattern
                    cur_mem = int(
                        abs(memory_dict[prog_pid]-init_memory[prog_pid]))
                    if pattern.get(suspect_name) is not None:
                        pattern[suspect_name] = pattern.get(suspect_name) + \
                            list((time.time(),
                                  cur_mem))
                    else:
                        pattern[suspect_name] = list((time.time(), cur_mem))

        # time series pattern detection

        counter = detect_pattern(pattern, white_list=white_list)
        # delete pattern to dump a new one
        del pattern
        pattern = dict()
        alarm = True

        for program_name in counter.keys():
            black_list[program_name] = black_list.get(program_name, 0) + 1
            if not (black_list[program_name] in terminated):
                if black_list[program_name] >= del_threshold:

                    # alarm

                    if alarm:
                        # playsound(str(os.getcwd())+"/sounds/seha7.wav")
                        alarm = False

                    # get the name from data[memory big dictionary]
                    print(
                        '----------------------------   ATTENTION  ----------------------------')
                    print('Suspected a Malicious Behaviour from Program -->', program_name)
                    # get process path from monitor
                    suspect_path = monitor.get_process_path(program_name)
                    # check crypto from utils
                    # thread

                    inp = utils.timout_input(time=10)

                    if inp.lower() in ['y', 'yes', 'ok']:
                        print('Booooom Headshot Process', program_name)
                        # Killing all processes that have the same name
                        terminated.add(program_name)
                        print("added to termination set", terminated)

                        pids = set(name_pid_dict[program_name])
                        for a_pid in pids:
                            terminate(int(a_pid))

                        path = "addf"
                        try:

                            # get path from pid
                            path = monitor.get_process_path(program_name)
                            # cr.check_exe_path(os.getcwd(), path)

                            # block or encrypt
                            encr_class.encrypt(path)
                        except:
                            # cr.check_exe_path(os.getcwd(), suspect_path)
                            pass
                            #print('pid replaced y norm', program_name)

                        # encrypt the process
                        # kill it
                        # thread to user if he wanted back
                    else:
                        white_list.add(program_name)
                        print('added to white_list')
                        continue
        del counter


def main():
    """

    threading for crypto, monitor save white&black lists history data
    crypto gpu > 10%

    """

    # to ignore annoying python warnings
    warnings.filterwarnings('ignore')

    # retrieve database

    key = "skfjgmkgzk"
    ecr = EN(key)

    # globals
    # retrive db
    init_memory = dict()
    black_list = dict()
    pattern = dict()
    white_list = set()
    terminated = set()

    # every 10 min save to db
    white_list, black_list = db_utils.read_db()
    db_thread = threading.Thread(target=periodic_update.periodic_db,
                                 kwargs={'white_list': white_list, 'black_list': black_list})
    db_thread.start()

    # every 10 min loop through hashes
    hash_thread = threading.Thread(target=periodic_update.periodic_hash_check)
    hash_thread.start()

    pack = dict(
        init_memory=init_memory,
        terminated=terminated,
        black_list=black_list,
        white_list=white_list,
        pattern=pattern
    )

    main_monitor(terminate=monitor.terminate_process,
                 shell_memory_function=monitor.getListOfProcessSortedByMemory,
                 encr_class=ecr,
                 del_threshold=2,
                 **pack)


if __name__ == "__main__":
    main()
