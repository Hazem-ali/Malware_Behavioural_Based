"main.py"

#imports
import time
import math
import monitor
import utils
import db_utils
import numpy as np
import crypto_check as cr
import os
import threading as th
from encrytor import EN
import warnings
DOWNSAMPLING = 0.3







def detect_patt(pattern:dict,white_list:dict)->bool:
    """ pattern detection 
        using duty cylce , wave_length,
        args :
            * pattern (dict) : save the pattern 
        returns :
            * bool pattern detected or not
    """
    con = False
    for key,val in pattern.items():

        if key == "exp_creative_name_for_monitor_prevent_match_with_another_prog_name" or \
            (key in white_list.key()):
            print("prog",key,"is white listed")
            continue

        m_arr = np.array([itr[1] for itr in val]).flatten()
        t_arr = np.array([itr[0] for itr in val]).flatten()
        # be aware of processes that uses the same memory always will get zero
        threshold=(m_arr.max()+m_arr.min())/2.0
        mask_upper = m_arr > threshold
        mask_lower = m_arr <= threshold
        # numeric shift mask
        mask = np.where(m_arr > threshold)[0]
        #print("mask",mask)
        shift_mask = mask[:mask.shape[0]-1]
        shift_mask = np.hstack((shift_mask[0],shift_mask))
        a = mask - shift_mask
        #print('mask',shift_mask)
        #print(a[a>1.0])
        set_val = set(a[a>1.0])
        #print(set_val)
        #print(len(set_val)<=3)
        con = bool(len(set_val)<=3)
        # ######### #
        #condtion = np.abs(np.sum((m_arr > m_arr.min())) - np.sum(~(m_arr > m_arr.min())))\
        #    < int(math.ceil(0.2*m_arr.shape[0]))
        if con:
            print("pattern")
        return con

def main_monitor(terminate, shell_memory_function,encr_class,
    init_memory:dict,
    init_times:dict,
    time_black_list:dict,
    white_list:set,
    pattern:dict,
    del_threshold: int = 3) -> (dict,dict):
    """
    monitor the memory
    args:
        * terminate :function to kill the process with pid
        * shell_memory_function: it retrieves current memory data
        * init_memory (dict)
        * init_times (dict)
        * time_black_list (dict)
        * white_list (set)
        * pattern (dict)

    """

    def get_memory(list_dict: list):
        """"""
        memory, exe_name , name_pid = dict(), dict(), dict()
        for process in list_dict:
            memory[process['pid']] = process['data']
            exe_name[process['pid']] = process['name']

            if name_pid.get(process['name']) is None:
                name_pid[process['name']] = [process['pid']]
            else :
                name_pid[process['name']] = name_pid.get(process['name']) + [process['pid']]
        return memory,exe_name,name_pid

    def get_proccess_name(memory: dict) -> list:
        return list(set(memory.keys()))

    while True:

        init_monitor_time = time.time()
        while int(time.time()-init_monitor_time) < 15:
            data = shell_memory_function()
            memory, exe_name,name_pid = get_memory(data)
            #######################
            #proccesses = get_proccess_name(memory)
            
            # perfecto
            #{ pid : exe_name.get(pid) for pid in proccesses}
            
            new_processes = set(exe_name.values()).difference(white_list)
            #new_processes_pid = list(np.array([ np.array(name_pid.get(name).flatten() for name in new_proccesses]).flatten())
            
            new_processes_pid = []
            [new_processes_pid.extend(*name_pid.get(name)) for  name in new_processes]

            #for  name in new_proccesses:
                #new_processes_pid.append(*name_pid.get(name))

            # for prog_pid in proccesses:
            for prog_pid in new_processes_pid:

                if (init_memory.get(prog_pid) is None) or\
                                init_memory.get(prog_pid) > memory[prog_pid]:

                    init_memory[prog_pid] = memory[prog_pid]
                # sampling condtion 
                suspect_name = exe_name.get(prog_pid)
                cond = np.random.choice([False, True], size=(1,), p=[abs(1-DOWNSAMPLING), DOWNSAMPLING])[0]

                if cond: # append pattern
                    cur_mem = int(abs(memory[prog_pid]-init_memory[prog_pid]))
                    pattern[suspect_name] = pattern.get(suspect_name)+\
                                        list(tuple(time.time(),
                                            cur_mem))


                """# pattern numpy approach
                cur_mem = 5
                timer = time.time() # or just index we will see
                ##############################################
                pattern[prog_pid] = pattern.get(prog_pid)+\
                                        list(tuple(timer,
                                            cur_mem))
                #"""


                # if int(abs(memory[prog_pid]-init_memory[prog_pid])) >= 5:

                #     if (init_times.get(prog_pid) is None) or\
                #                  (time.time() - init_times.get(prog_pid) > 10):
                #         #(time.time() - init_times.get(prog_pid) > 10)
                #         """if pattern.get('strt') is None:
                #             pattern['strt'] = pattern.get('strt')"""

                #         init_times[prog_pid] = time.time()
                #         print('initial time for ', prog_pid)
                #     """if (time.time() - init_times.get(prog_pid) > 10):
                #         init_times[prog_pid] = time.time()
                #         print('initial time for ', prog_pid)"""

                # if init_times.get(prog_pid) is not None:
                #     # time pattern
                #     if math.ceil(int(abs(init_times.get(prog_pid)-time.time()))) > 1 :
                #         time_black_list[prog_pid] = time_black_list.get(prog_pid, 0) + 1
                #         init_times[prog_pid] = time.time() # Resetting the time for the process

                #         print('Program with pid '+str(prog_pid) + ' Blacklisted')

                # if time_black_list.get(prog_pid) is not None:
                #     # always blocked
                #     if time_black_list[prog_pid] >= del_threshold:
                #         if suspect_name in white_list:
                #             print("prog",suspect_name,"with pid",prog_pid,"is white listed")
                #             continue

                #         # get the name from data[memory big dictionary]
                #         suspect_name = exe_name.get(prog_pid)
                #         print('----------------------------   DETECTED   ----------------------------')
                #         print('suspected a malicious behaviour from pogram', suspect_name)
                #         # get process path from monitor
                #         suspect_path=monitor.get_process_path(prog_pid)
                #         # check crypto from utils
                #         # thread
                #         cr.check_exe_path(os.getcwd(),suspect_path)

                #         inp = utils.timout_input(time=10)

                #         if inp.lower() in ['y','yes','ok']:
                #             print('Booooom Headshot Process', prog_pid)
                #             terminate(prog_pid)
                #             print("terminated",suspect_name,suspect_path)
                #             # block or encrypt
                #             # get path from pid
                #             # encrept the process
                #             # kill it
                #             # thread to  user if he wanted back
                #             # os.system("taskkill /f /im [suspect_name].exe")
                #             #os.remove("/tmp/<file_name>.txt")
                #         elif inp.lower() in ["n","no"]:
                #             white_list.add(exe_name[prog_pid])

        # get my pid
        # to not kill my self allah yerhak y zalta
        # remove python3 if it was in whitelist
        # add it in new_processes set

        # time series pattern detection
        # if whitelist
        counter = detect_patt(pattern,white_list=white_list)
        print(counter)
        # black list counter
        if counter :
            time_black_list[prog_pid] = time_black_list.get(prog_pid, 0) + 1
            #if time_black_list.get(prog_pid) is not None:
        #if time_black_list.get(prog_pid) is not None:
        if time_black_list[prog_pid] >= del_threshold:
            " elgeded "
            # get the name from data[memory big dictionary]
            #suspect_name = exe_name.get(prog_pid)
            print('----------------------------   DETECTED   ----------------------------')
            print('suspected a malicious behaviour from pogram', suspect_name)
            # get process path from monitor
            suspect_path=monitor.get_process_path(prog_pid)
            # check crypto from utils
            # thread
            cr.check_exe_path(os.getcwd(),suspect_path)

            inp = utils.timout_input(time=10)

            if inp.lower() in ['y','yes','ok']:
                print('Booooom Headshot Process', prog_pid)
                terminate(prog_pid)
                print("terminated",suspect_name,suspect_path)
                path = "addf"
                try:
                    # get path from pid
                    path = monitor.get_process_path(prog_pid)
                    # block or encrypt
                    encr_class.encrypt(path)
                except:
                    print('pid replaced y norm',prog_pid)
                
                # encrept the process
                # kill it
                # thread to  user if he wanted back
                # os.system("taskkill /f /im [suspect_name].exe")
                #os.remove("/tmp/<file_name>.txt")
            elif inp.lower() in ["n","no"]:
                white_list.add(exe_name[prog_pid])

def main():
    """
    threading for crypto , monitor save white&black lists history data

    crypto gpu > 10%"""

    # to ignore annoying python warnings
    warnings.filterwarnings('ignore')

    #key = str(input("enter encr key"))
    key = "skfjgmkgzk"
    ecr_class = EN(key)



    # globals
    init_memory = dict()
    init_times = dict()
    time_black_list = dict()
    pattern = dict(exp_creative_name_for_monitor_provent_match_with_another_prog_name= [])
    white_list = set()
    white_list = utils.whitelist_scraper()

    pack = dict(
        init_memory=init_memory,
        init_times=init_times,
        time_black_list=time_black_list,
        white_list= white_list,
        pattern=pattern
        )

    main_monitor(monitor.terminate_process,ecr_class,
                 monitor.getListOfProcessSortedByMemory,**pack,del_threshold=10)

    # every 10 min save the dictionaries

if __name__ == "__main__":
    main()
