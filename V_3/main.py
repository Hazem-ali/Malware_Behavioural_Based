"main.py"

# imports
import os
import warnings
#import enum
import time
#import math

import threading
import numpy as np
from playsound import playsound

import periodic_update
import monitor
import utils
import db_utils
# import crypto_check as cr
from encrytor import EN


DOWNSAMPLING = 0.3

# event = threading.Event()

# def fn():
#     # print(45)
#     event.wait()
#     print("done")

# t1 = threading.Thread(target=fn)
# t1.start()


def is_white_listed(item, whitelist):
    for i in whitelist:
        if item.strip() == i.strip():
            return True
    return False


def detect_patt(pattern: dict, white_list: dict) -> dict:
    """ pattern detection 
        using duty cylce , wave_length,
        args :
            * pattern (dict) : save the pattern
        returns :
            * bool pattern detected or not
    """
    con = False
    # print(pattern["Malware"])
    # if "Malware" in white_list:
    # print("LOL")
    # print(type(white_list))
    # print("pattern.items")
    # print(pattern.items())
    # print(pattern.keys())
    conditions = dict()
    for key, val in pattern.items():
        #print("key", key)
        if key in white_list:
            print("prog", key, "is white listed")
            continue
        # print(key)
        m_arr = np.array([itr for itr in val]).flatten()
        t_arr = np.array([itr for itr in val]).flatten()
        # be aware of processes that uses the same memory always will get zero
        if m_arr.shape[0] > 2:
            # if key == "Malware":
            #     print("Malware pattern saved")
            threshold = (m_arr.max()+m_arr.min())/2.0
            mask_upper = m_arr > threshold
            mask_lower = m_arr <= threshold
            l1 = np.sum(mask_upper)
            l2 = np.sum(mask_lower)
            duty_cycle = np.maximum( l1 , l2)/(l1 + l2)
            # numeric shift mask
            mask = np.where(m_arr > threshold)[0]
            # print("mask",mask)
            shift_mask = mask[:mask.shape[0]-1]
            shift_mask = np.hstack((shift_mask[0], shift_mask))
            mask -= shift_mask
            #a = mask - shift_mask
            # print('mask',shift_mask)
            # print(a[a>1.0])
            set_val = set(mask[mask > 1.0])
            # print("set_val")
            # print(set_val)
            # print(len(set_val))
            con = bool(len(set_val) <= 3)
            # ######### #
            # condtion = np.abs(np.sum((m_arr > m_arr.min())) - np.sum(~(m_arr > m_arr.min())))\
            #    < int(math.ceil(0.2*m_arr.shape[0]))
        if con:
            # if key == "Malware":
            #     print("Malware pattern detected")
            # print("pattern",key)
            conditions[key] = True
    return conditions



def main_monitor(terminate, shell_memory_function, encr_class,
                 init_memory: dict,
                 terminated: set,
                 black_list: dict,
                 white_list: set,
                 pattern: dict,
                 del_threshold: int = 3):
    """
    monitor the memory
    args:
        * terminate :function to kill the process with pid
        * shell_memory_function: it retrieves current memory data
        * init_memory (dict)
        * init_times (dict)
        * black_list (dict)
        * white_list (set)
        * pattern (dict)

    """
    while True:

        init_monitor_time = time.time()
        while int(time.time()-init_monitor_time) < 15:
            
            data = shell_memory_function()
            memory, exe_name, name_pid = utils.get_memory(data)
            #######################
            #proccesses = get_proccess_name(memory)

            # perfecto
            #{ pid : exe_name.get(pid) for pid in proccesses}

            new_processes = set(exe_name.values()).difference(white_list)
            # new_processes_pid = list(np.array([ np.array(name_pid.get(name).flatten() for name in new_proccesses]).flatten())

            new_processes_pid = []
            [
                new_processes_pid.extend(name_pid.get(name))
                    for name in new_processes
            ]

            # for  name in new_proccesses:
            # new_processes_pid.append(*name_pid.get(name))
            # for prog_pid in proccesses:
            for prog_pid in new_processes_pid:                
                suspect_name = exe_name.get(prog_pid)
                if suspect_name in terminated:
                    print("in the if condition")
                    # event listener
                    "git"
                    pids = set(suspect_name)
                    for pid in pids:
                        print("in the killing loop")
                        terminate(int(pid))

                if (init_memory.get(prog_pid) is None) or\
                        init_memory.get(prog_pid) > memory[prog_pid]:

                    init_memory[prog_pid] = memory[prog_pid]
                # sampling condtion
                suspect_name = exe_name.get(prog_pid)
                cond = np.random.choice([False, True], size=(
                    1,), p=[abs(1-DOWNSAMPLING), DOWNSAMPLING])[0]

                if cond:  # append pattern
                    # print("Memory...")
                    cur_mem = int(abs(memory[prog_pid]-init_memory[prog_pid]))
                    if pattern.get(suspect_name) is not None:
                        pattern[suspect_name] = pattern.get(suspect_name) + \
                            list((time.time(),
                                  cur_mem))
                    else:
                        pattern[suspect_name] = list((time.time(), cur_mem))

        # time series pattern detection
        # if whitelist

        counter = detect_patt(pattern, white_list=white_list)
        # delete pattern to dump a new one
        del pattern
        pattern = dict()
        alarm=True

        for prog_pid in counter.keys():
            black_list[prog_pid] = black_list.get(prog_pid, 0) + 1
            # if black_list.get(prog_pid) is not None:
            if black_list[prog_pid] >= del_threshold:
                # alarm
                if alarm:
                    playsound(str(os.getcwd())+"\\sounds\\seha7.wav")
                    alarm=False

                # get the name from data[memory big dictionary]
                #suspect_name = exe_name.get(prog_pid)
                print(
                    '----------------------------   A MALWARE DETECTED   ----------------------------')
                print('suspected a malicious behaviour from pogram', prog_pid)
                # get process path from monitor
                suspect_path = monitor.get_process_path(prog_pid)
                # check crypto from utils
                # thread

                inp = utils.timout_input(time=10)

                if inp.lower() in ['y', 'yes', 'ok']:
                    print('Booooom Headshot Process', prog_pid)
                    # Killing all processes that have the same name
                    terminated.add(prog_pid)
                    print("added to termination set", terminated)

                    pids = set(name_pid[prog_pid])
                    for a_pid in pids:
                        terminate(int(a_pid))

                    print("terminated", suspect_name, suspect_path)
                    print("terminated 1", prog_pid, suspect_path)
                    path = "addf"
                    try:

                        # get path from pid
                        path = monitor.get_process_path(prog_pid)
                        # cr.check_exe_path(os.getcwd(), path)

                        # block or encrypt
                        encr_class.encrypt(path)
                    except:
                        # cr.check_exe_path(os.getcwd(), suspect_path)
                        pass
                        #print('pid replaced y norm', prog_pid)

                    # encrept the process
                    # kill it
                    # thread to  user if he wanted back
                    # os.system("taskkill /f /im [suspect_name].exe")
                    # os.remove("/tmp/<file_name>.txt")
                else:
                    white_list.add(prog_pid)
                    print('added to white_list')
                    continue
        del counter

def main():
    """
    threading for crypto , monitor save white&black lists history data

    crypto gpu > 10%"""

    # to ignore annoying python warnings
    warnings.filterwarnings('ignore')

    # retrieve data base

    #key = str(input("enter encr key"))
    key = "skfjgmkgzk"
    ecr = EN(key)

    # globals
    # retrive db
    init_memory = dict()
    black_list = dict()
    pattern = dict()
    white_list = set()
    terminated = set()

    # every 10 min save to db
    db_thread = threading.Thread(target=periodic_update.periodic_db,
            kwargs={'white_list':white_list,'black_list':black_list})
    db_thread.start()


    # every 10 min loop through hashes
    hash_thread = threading.Thread(target=periodic_update.periodic_hash_check)
    hash_thread.start()

    pack = dict(
        init_memory=init_memory,
        terminated=terminated,
        black_list=black_list,
        white_list=white_list,
        pattern=pattern
    )

    main_monitor(terminate=monitor.terminate_process,
                 shell_memory_function=monitor.getListOfProcessSortedByMemory,
                 encr_class=ecr,
                 del_threshold=2,
                 **pack)


if __name__ == "__main__":
    main()
