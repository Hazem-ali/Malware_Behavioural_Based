import time
import math
import monitor
import user_input
#import threading as th



"globals"
initial_memory = dict()
init_init_times = dict()
time_black_list = dict()
pattern = dict()


def whitelist_scraper(path:str = "result.txt")->dict:
    """
    add trusted processes names to not checking them and save time 
    """

    def get_white_list(list_:list)->list:
        return set([i.split('\'')[5] for i in list_])
    
    def create_whitelist(set_whilist_names:set)->dict:
        return { i:1 for i in set_whilist_names}
    
    lis = []
    with open(path, "r") as f:
        lines = f.readlines()
        lis= [ l for l in lines]

    set_whilist_names= get_white_list(lis)
    return create_whitelist(set_whilist_names)


def Main_Monitor(terminate, shell_memory_function, del_threshold: int = 3) -> (dict,dict):

    def get_memory(list_dict: list):
        """"""
        memory, exe_name = dict(), dict()
        for process in list_dict:
            memory[process['pid']] = process['data']
            exe_name[process['pid']] = process['name']
        return memory,exe_name

    def get_proccess_name(memory: dict) -> list:
        return list(set(memory.keys()))

    global initial_memory
    global init_times
    global time_black_list
    global white_list
    global pattern

    while True:
        data = shell_memory_function()
        memory, exe_name = get_memory(data)
        proccesses = get_proccess_name(memory)
        # perfecto
        new_proccesses = set(get_proccess_name(proccesses)).difference((set(white_list)))
        
        for prog_pid in proccesses:

            if initial_memory.get(prog_pid) == None or initial_memory.get(prog_pid) > memory[prog_pid]:
                initial_memory[prog_pid] = memory[prog_pid]

            if int(abs(memory[prog_pid]-initial_memory[prog_pid])) >= 20:

                if (init_times.get(prog_pid) == None) or (time.time() - init_times.get(prog_pid) > 10):
                    #(time.time() - init_times.get(prog_pid) > 10)
                    if pattern.get('strt') == None:
                        pattern['strt'] = pattern.get('strt')

                    init_times[prog_pid] = time.time()
                    print('initial time for ', prog_pid)
                if (time.time() - init_times.get(prog_pid) > 10):           
                    init_times[prog_pid] = time.time()
                    print('initial time for ', prog_pid)

            if init_times.get(prog_pid) is not None:
                # time pattern
                if math.ceil(int(abs(init_times.get(prog_pid)-time.time()))) > 1 :
                    time_black_list[prog_pid] = time_black_list.get(prog_pid, 0) + 1
                    init_times[prog_pid] = time.time() # Resetting the time for the process

                    print('Program with pid '+str(prog_pid) + ' Blacklisted')

            if time_black_list.get(prog_pid) is not None:
                """"""
                # always blocked 
                if time_black_list[prog_pid] >= del_threshold:
                    if white_list.get(prog_pid) == 1:
                        print(prog_pid,"is white listed")
                        continue

                    # get the name from data[memory big dictionary]
                    suspect_name = exe_name[prog_pid]
                    print('----------------------------   DETECTED   ----------------------------')
                    print('suspected a malicious behaviour from pogram', suspect_name)

                    inp = user_input.timout_input(time=3)

                    if inp.lower() in ['y','yes','ok']:                                        
                        print('Booooom Headshot Process', prog_pid)
                        terminate(prog_pid)
                        
                        # block or encrypt
                        # os.system("taskkill /f /im [suspect_name].exe")
                        #os.remove("/tmp/<file_name>.txt")
                    elif inp.lower() in ["n","no"]:
                        white_list[prog_pid] = 1

def main():
    "threading for crypto , monitor save white&black lists history data "
    white_list = dict()
    white_list = whitelist_scraper();

    Main_Monitor(monitor.terminate_process,
                 monitor.getListOfProcessSortedByMemory)

if __name__ == "__main__":
    main()
