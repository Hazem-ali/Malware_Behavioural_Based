"""utils"""

# imports
import os
from typing import List, Optional, Union
from inputimeout import inputimeout, TimeoutOccurred

# please install de ya norm
# pip install inputimeout


def timout_input(time:int=3)->str:
    """ timingout for the user input to auto block the process
    args:
        * time (int): timeout time default value of 3
    returns:
        * (str) user answer
    """
    try:
        usr_answer = inputimeout(
            prompt='do you want to block the process [auto block in {}S] (y/n) ?\n'.format(time)
            , timeout=time)
        return usr_answer
    except TimeoutOccurred:
        usr_answer = 'y'
        return usr_answer

def whitelist_scraper(path:str = "result.txt")->set:
    """
    add trusted processes names to not checking them and save time
    args:
        * path (str): timeout time default value of 3
    returns:
        * (str) user answer
    """

    def list_to_set(list_:list)->set:
        return set([i.split('\'')[5] for i in list_])

    def set_to_dict(set_whilist_names:set)->dict:
        return { i:1 for i in set_whilist_names}

    lis = []
    with open(path, 'r',encoding='UTF-8') as file_:
        lines = file_.readlines()
        lis= [ l for l in lines]

    whilist_names_set= list_to_set(lis)
    return whilist_names_set

def get_proccess_name(memory: dict) -> list:
    return list(set(memory.keys()))

def get_memory(list_dict: list)->tuple((dict, dict, dict)):
    memory, exe_name, name_pid = dict(), dict(), dict()
    for process in list_dict:
        memory[process['pid']] = process['data']
        exe_name[process['pid']] = process['name']

        if name_pid.get(process['name']) is None:
            name_pid[process['name']] = [process['pid']]
        else:
            name_pid[process['name']] = name_pid.get(
                process['name']) + [process['pid']]
    return memory, exe_name, name_pid

def search_files_in_directory(
    extension: str,
    directory: Optional[str] = None,
    ) -> Union[List[str or None]]:
    """
    search_files_in_directory

    Args:
        extension: the extension of the files to search for
        directory: the directory to search in

    Returns:
        a list (str) of file pathes with the given extension in the given directory
    """
    def return_path(root:str,file_name: str,extension:str) -> str or None:
        """
        return_path

        Args:
            file_name: the name of the file to return the path for

        Returns:
            the path to the file with the given name
        """
        if file_name.endswith(extension):
            if not root.endswith(os.sep):
                root += os.sep
            return str(root)+str(file_name)
    # error handling
    if directory is None:
        directory = os.getcwd()
    if not directory.endswith(os.sep):
        directory += os.sep
    if extension.startswith(os.sep):
        extension = extension[1:]
    if not extension.startswith("."):
        extension = "." + extension

    # search for files
    pathes = list(map(lambda x :list(
                    map(lambda file: return_path(x[0],file,extension),x[2]))
            ,os.walk(directory)))
    # remove empty lists
    pathes = list(filter(lambda x: x != [], pathes))
    # flatten list
    pathes = [item for sublist in pathes for item in sublist]
    # remove None values
    pathes = list(filter(lambda x: x is not None, pathes))
    return pathes

def in_string(rule:str,string:str)->bool:
    """
    check if rule in string

    Args:
        rule: the string to check
        string: the string to check rule in

    Returns:
        True if rule in string, False if not
    """
    return rule in string
