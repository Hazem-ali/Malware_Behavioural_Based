from asyncore import write
import psutil
import shutil
import os, signal


def get_process_path(name: str)->str:
    process = shutil.which(name)
    process_path = process
    return process_path


def getListOfProcessSortedByMemory():

    listOfProcDicts = []

    for my_process in psutil.process_iter():
        # getting data from every process
        try:
            # Dictionarizing process details
            process_info = my_process.as_dict(attrs=['pid', 'name'])

            process_info['vms'] = my_process.memory_info().vms / (1024 * 1024)
            process_info['text'] = my_process.memory_info().text
            process_info['data'] = my_process.memory_info().data / \
                (1024 * 1024)
            process_info['rss'] = my_process.memory_info().rss / (1024 * 1024)

            listOfProcDicts.append(process_info)
        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
            pass

    # Sort list of dict by key vms i.e. memory usage
    listOfProcDicts = sorted(
        listOfProcDicts, key=lambda procObj: procObj['data'], reverse=True)
    return listOfProcDicts


def write_to_text_file(data):
    with open('result.txt', 'w') as f:
        for item in data:
            f.write(str(item))
            f.write('\n')

def create_short_dict(data)->list:
    result = []
    for item in data:
        tmp = {}
        tmp['name'] = item['name']
        tmp['pid'] = item['pid']
        tmp['data'] = item['data']
        result.append(tmp)

    return result


def terminate_process(pid):
    os.kill(pid, signal.SIGKILL)
    print("Process Killed Successfully")
    return


x = getListOfProcessSortedByMemory()
write_to_text_file(x)
